<!DOCTYPE html>
<html>
<head>
    <title>Interactive Particle Human Figure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body { 
            margin: 0; 
            background: black;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: system-ui, -apple-system, sans-serif;
            color: white;
            overflow: hidden;
        }
        .controls {
            padding: 20px;
            width: 100%;
            max-width: 1200px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            background: rgba(0,0,0,0.7);
            position: fixed;
            top: 0;
            z-index: 100;
        }
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 5px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }
        button, select {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }
        button:hover, select:hover {
            background: rgba(255,255,255,0.2);
        }
        button.active {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.4);
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
        }
        #recordingIndicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: red;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <button id="menBtn" class="active">Men</button>
            <button id="womenBtn">Women</button>
        </div>
        <div class="control-group">
            <select id="poseSelect">
                <option value="standing">Standing</option>
                <option value="walking">Walking</option>
                <option value="running">Running</option>
                <option value="dancing">Dancing</option>
                <option value="explode">Explode</option>
                <option value="vortex">Vortex</option>
                <option value="wave">Wave</option>
            </select>
        </div>
        <div class="control-group">
            <button id="colorBtn">Colors</button>
            <button id="trailBtn">Trails</button>
            <button id="glowBtn">Glow</button>
            <button id="connectBtn">Connect</button>
            <button id="3dBtn">3D Effect</button>
        </div>
        <div class="control-group">
            <button id="recordVideoBtn">Record Video</button>
            <button id="stopRecordingBtn" style="display:none;">Stop Recording</button>
        </div>
    </div>

    <div id="recordingIndicator">Recording... <span id="recordingTime">0:00</span></div>
    
    <canvas id="canvas"></canvas>

    <script>
        // Canvas and core setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const particles = [];

        // Mouse interaction setup
        const mouse = {
            x: undefined,
            y: undefined,
            radius: 100
        };

        // Configuration variables
        let currentGender = 'men';
        let currentPose = 'standing';
        let useColors = false;
        let useTrails = false;
        let useGlow = false;
        let useConnect = false;
        let use3D = false;

        // Resize canvas to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init(); // Regenerate figure on resize
        }

        // Color palettes
        const colorPalettes = {
            neon: ['#FF3366', '#33FF99', '#3366FF', '#FFFF33'],
            plasma: ['#FF1493', '#9400D3', '#4B0082', '#8A2BE2'],
            fire: ['#FF4500', '#FF6347', '#FF7F50', '#FF8C00'],
            ocean: ['#00CED1', '#20B2AA', '#5F9EA0', '#4682B4']
        };
        let currentPalette = colorPalettes.neon;

        // Particle class with advanced features
        class Particle {
            constructor(x, y, bodyPart) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.bodyPart = bodyPart;
                this.size = Math.random() * 2 + 1;
                this.color = useColors 
                    ? currentPalette[Math.floor(Math.random() * currentPalette.length)] 
                    : 'white';
                this.velocity = { x: 0, y: 0 };
                this.trail = [];
                this.force = 0;
                this.angle = Math.random() * Math.PI * 2;
                this.z = Math.random() * 100;
                this.baseZ = this.z;
                this.originalSize = this.size;
            }

            draw() {
                // Glow effect
                if (useGlow) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = useColors ? this.color : 'white';
                } else {
                    ctx.shadowBlur = 0;
                }

                // Trails
                if (useTrails) {
                    this.trail.forEach((trailPoint, index) => {
                        ctx.beginPath();
                        let size = this.size * (index / this.trail.length);
                        if (use3D) {
                            size *= (this.z + 100) / 200;
                        }
                        ctx.arc(trailPoint.x, trailPoint.y, size, 0, Math.PI * 2);
                        ctx.fillStyle = useColors ? 
                            `${this.color}${Math.floor((index / this.trail.length) * 255).toString(16).padStart(2, '0')}` : 
                            `rgba(255,255,255,${index / this.trail.length})`;
                        ctx.fill();
                    });
                }

                // Main particle
                ctx.beginPath();
                let drawSize = this.size;
                if (use3D) {
                    drawSize *= (this.z + 100) / 200;
                }
                ctx.arc(this.x, this.y, drawSize, 0, Math.PI * 2);
                ctx.fillStyle = useColors ? this.color : 'white';
                ctx.fill();

                // Connection lines
                if (useConnect) {
                    this.connect();
                }
            }

            connect() {
                particles.forEach(particle => {
                    const dx = this.x - particle.x;
                    const dy = this.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 50 && distance > 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = useColors ? 
                            `${this.color}${Math.floor((1 - distance/50) * 255).toString(16).padStart(2, '0')}` : 
                            `rgba(255,255,255,${1 - distance/50})`;
                        ctx.lineWidth = 1;
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(particle.x, particle.y);
                        ctx.stroke();
                    }
                });
            }

            update(timestamp) {
                // Mouse interaction explosion
                if (mouse.x && mouse.y) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < mouse.radius) {
                        const angle = Math.atan2(dy, dx);
                        const force = (mouse.radius - distance) / mouse.radius;
                        
                        // Explosion effect
                        this.velocity.x -= Math.cos(angle) * force * 5;
                        this.velocity.y -= Math.sin(angle) * force * 5;
                        
                        // Size change
                        this.size = this.originalSize * (1 + force * 2);
                    } else {
                        // Return to original size and position
                        this.size += (this.originalSize - this.size) * 0.1;
                    }
                }

                // Pose-based movement
                let targetX = this.baseX;
                let targetY = this.baseY;
                let targetZ = this.baseZ;

                switch(currentPose) {
                    case 'walking':
                        if (['leftLeg', 'rightLeg'].includes(this.bodyPart)) {
                            targetX += Math.sin(timestamp/500 + (this.bodyPart === 'leftLeg' ? 0 : Math.PI)) * 20;
                        }
                        if (['leftArm', 'rightArm'].includes(this.bodyPart)) {
                            targetX += Math.sin(timestamp/500 + (this.bodyPart === 'leftArm' ? Math.PI : 0)) * 15;
                        }
                        break;

                    case 'running':
                        if (['leftLeg', 'rightLeg'].includes(this.bodyPart)) {
                            targetX += Math.sin(timestamp/300 + (this.bodyPart === 'leftLeg' ? 0 : Math.PI)) * 30;
                            targetY += Math.abs(Math.sin(timestamp/300)) * 10;
                        }
                        if (['leftArm', 'rightArm'].includes(this.bodyPart)) {
                            targetX += Math.sin(timestamp/300 + (this.bodyPart === 'leftArm' ? Math.PI : 0)) * 25;
                            targetY -= Math.abs(Math.sin(timestamp/300)) * 15;
                        }
                        break;

                    case 'dancing':
                        targetX += Math.sin(timestamp/1000 + this.baseY/30) * 20;
                        targetY += Math.cos(timestamp/1000 + this.baseX/30) * 20;
                        if (['leftArm', 'rightArm'].includes(this.bodyPart)) {
                            targetY += Math.sin(timestamp/500) * 30;
                        }
                        break;

                    case 'explode':
                        this.force += 0.2;
                        targetX += Math.cos(this.angle) * this.force;
                        targetY += Math.sin(this.angle) * this.force;
                        break;

                    case 'vortex':
                        const centerX = canvas.width/2;
                        const centerY = canvas.height/2;
                        const angle = Math.atan2(this.y - centerY, this.x - centerX);
                        const distance = Math.sqrt(Math.pow(this.x - centerX, 2) + Math.pow(this.y - centerY, 2));
                        targetX = centerX + Math.cos(angle + 0.02) * distance;
                        targetY = centerY + Math.sin(angle + 0.02) * distance;
                        break;

                    case 'wave':
                        targetY += Math.sin(timestamp/500 + this.x/50) * 30;
                        break;
                }

                // Apply velocity
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // Damping
                this.velocity.x *= 0.95;
                this.velocity.y *= 0.95;

                // Return to base position
                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;

                // Trail management
                if (useTrails) {
                    this.trail.unshift({ x: this.x, y: this.y });
                    if (this.trail.length > 10) this.trail.pop();
                }

                // 3D effect management
                if (use3D) {
                    this.z += (targetZ - this.z) * 0.1;
                }
            }
        }

        // Mouse event listeners
        canvas.addEventListener('mousemove', (event) => {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.x = undefined;
            mouse.y = undefined;
        });

        // Detailed figure generation function
        function init() {
            particles.length = 0; // Clear existing particles
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 - 100;
            const legSpread = currentGender === 'men' ? 60 : 50;

            function shouldCreateParticle(x, y) {
                const relX = x - centerX;
                const relY = y - centerY;
                
                if (currentGender === 'men') {
                    // Head
                    if (Math.sqrt(relX * relX + relY * relY) < 35) {
                        return { create: true, bodyPart: 'head' };
                    }
                    
                    // Neck
                    if (relY >= 35 && relY <= 55 && Math.abs(relX) < 20) {
                        return { create: true, bodyPart: 'neck' };
                    }
                    
                    // Shoulders and arms
                    if (relY >= 55 && relY <= 100) {
                        const shoulderCurve = Math.sqrt(1 - Math.pow((relY - 77.5) / 22.5, 2)) * 90;
                        if (Math.abs(relX) < shoulderCurve) {
                            return { 
                                create: true, 
                                bodyPart: relX < 0 ? 'leftArm' : 'rightArm' 
                            };
                        }
                    }
                    
                    // Torso
                    if (relY > 100 && relY <= 300) {
                        const waistWidth = 45 - Math.sin((relY - 100) / 50) * 10;
                        if (Math.abs(relX) < waistWidth) {
                            return { create: true, bodyPart: 'torso' };
                        }
                    }
                    
                    // Legs with explicit gap
        if (relY > 300 && relY <= 450) {
            const legWidth = 25;
            const legGap = 40; // Explicit gap between legs
            
            // Left leg condition
            if (relX < -legGap/2 - legWidth && relX > -legSpread && 
                Math.abs(relX - (-legSpread + legWidth/2)) < legWidth) {
                return { create: true, bodyPart: 'leftLeg' };
            }
            
            // Right leg condition
            if (relX > legGap/2 + legWidth && relX < legSpread && 
                Math.abs(relX - (legSpread - legWidth/2)) < legWidth) {
                return { create: true, bodyPart: 'rightLeg' };
            }
        }
    } else {
                    // Women's figure
                    // Head
                    if (Math.sqrt(relX * relX + relY * relY) < 30) {
                        return { create: true, bodyPart: 'head' };
                    }
                    
                    // Neck
                    if (relY >= 30 && relY <= 50 && Math.abs(relX) < 15) {
                        return { create: true, bodyPart: 'neck' };
                    }
                    
                    // Shoulders and arms
                    if (relY >= 50 && relY <= 90) {
                        const shoulderCurve = Math.sqrt(1 - Math.pow((relY - 70) / 20, 2)) * 70;
                        if (Math.abs(relX) < shoulderCurve) {
                            return { 
                                create: true, 
                                bodyPart: relX < 0 ? 'leftArm' : 'rightArm' 
                            };
                        }
                    }
                    
                    // Torso
                    if (relY > 90 && relY <= 300) {
                        let waistWidth;
                        if (relY < 180) {
                            waistWidth = 40 - ((relY - 90) / 90) * 15;
                        } else if (relY < 250) {
                            waistWidth = 25 + ((relY - 180) / 70) * 25;
                        } else {
                            waistWidth = 50 - ((relY - 250) / 50) * 15;
                        }
                        if (Math.abs(relX) < waistWidth) {
                            return { create: true, bodyPart: 'torso' };
                        }
                    }
                    
                    // Legs with gap
                    if (relY > 300 && relY <= 450) {
            const legWidth = 20;
            const legGap = 30; // Slightly smaller gap for women
            
            // Left leg condition
            if (relX < -legGap/2 - legWidth && relX > -legSpread && 
                Math.abs(relX - (-legSpread + legWidth/2)) < legWidth) {
                return { create: true, bodyPart: 'leftLeg' };
            }
            
            // Right leg condition
            if (relX > legGap/2 + legWidth && relX < legSpread && 
                Math.abs(relX - (legSpread - legWidth/2)) < legWidth) {
                return { create: true, bodyPart: 'rightLeg' };
            }
        }
    }
                
                return { create: false, bodyPart: null };
            }

            // Particle generation loop
            for (let y = centerY - 300; y < centerY + 300; y += 6) {
                for (let x = centerX - 200; x < centerX + 200; x += 6) {
                    const { create, bodyPart } = shouldCreateParticle(x, y);
                    if (create) {
                        particles.push(new Particle(x, y, bodyPart));
                    }
                }
            }
        }

        // Animation loop
        function animate(timestamp) {
            ctx.fillStyle = useTrails ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                particle.update(timestamp);
                particle.draw();
            });
            
            requestAnimationFrame(animate);
        }

        // Recording Setup
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingTimer = null;

        function startVideoRecording() {
            const stream = canvas.captureStream(30);
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm'
            });

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'particle_figure_recording.webm';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                recordedChunks = [];
            };

            mediaRecorder.start();
            recordingStartTime = Date.now();
            
            // Recording timer
            const recordingTimeEl = document.getElementById('recordingTime');
            document.getElementById('recordingIndicator').style.display = 'block';
            recordingTimer = setInterval(() => {
                const elapsedTime = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                recordingTimeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);

            document.getElementById('recordVideoBtn').style.display = 'none';
            document.getElementById('stopRecordingBtn').style.display = 'block';
        }

        function stopVideoRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                clearInterval(recordingTimer);
                document.getElementById('recordingIndicator').style.display = 'none';
                document.getElementById('recordVideoBtn').style.display = 'block';
                document.getElementById('stopRecordingBtn').style.display = 'none';
            }
        }

        // Event Listeners
        document.getElementById('menBtn').addEventListener('click', () => {
            currentGender = 'men';
            document.getElementById('menBtn').classList.add('active');
            document.getElementById('womenBtn').classList.remove('active');
            init();
        });

        document.getElementById('womenBtn').addEventListener('click', () => {
            currentGender = 'women';
            document.getElementById('menBtn').classList.remove('active');
            document.getElementById('womenBtn').classList.add('active');
            init();
        });

        document.getElementById('poseSelect').addEventListener('change', (e) => {
            currentPose = e.target.value;
            if (currentPose === 'explode') {
                particles.forEach(p => {
                    p.force = Math.random() * 5;
                    p.angle = Math.random() * Math.PI * 2;
                });
            }
        });

        document.getElementById('colorBtn').addEventListener('click', () => {
            useColors = !useColors;
            document.getElementById('colorBtn').classList.toggle('active');
            init(); // Regenerate with new colors
        });

        document.getElementById('trailBtn').addEventListener('click', () => {
            useTrails = !useTrails;
            particles.forEach(p => p.trail = []);
            document.getElementById('trailBtn').classList.toggle('active');
        });

        document.getElementById('glowBtn').addEventListener('click', () => {
            useGlow = !useGlow;
            document.getElementById('glowBtn').classList.toggle('active');
        });

        document.getElementById('connectBtn').addEventListener('click', () => {
            useConnect = !useConnect;
            document.getElementById('connectBtn').classList.toggle('active');
        });

        document.getElementById('3dBtn').addEventListener('click', () => {
            use3D = !use3D;
            document.getElementById('3dBtn').classList.toggle('active');
        });

        document.getElementById('recordVideoBtn').addEventListener('click', startVideoRecording);
        document.getElementById('stopRecordingBtn').addEventListener('click', stopVideoRecording);

        // Window resize handling
        window.addEventListener('resize', resizeCanvas);

        // Start the application
        resizeCanvas();
        animate(0);
    </script>
</body>
</html>
